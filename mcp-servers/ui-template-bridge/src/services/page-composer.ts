import path from 'path';
import { promises as fs } from 'fs';
import { writeFileAtomic } from './atomic-writer.js';

export interface ComposeSection {
  importPath: string; // e.g. '@/components/hero' or '../components/hero'
  componentName?: string; // optional explicit component name
  props?: Record<string, any>;
}

export interface ComposePageParams {
  sitePath: string; // root of Next.js app
  pagePath: string; // relative or absolute path, e.g., 'app/page.tsx' or '/abs/.../app/page.tsx'
  sections: ComposeSection[];
  overwrite?: boolean;
  dryRun?: boolean;
}

export interface ComposePageResult {
  success: boolean;
  path: string;
  changed: boolean;
  warnings: string[];
  errors: string[];
  preview?: string;
}

function toPascalCase(kebabOrFile: string): string {
  const base = kebabOrFile.replace(/\.[^.]+$/, '');
  return base
    .split(/[\/\-_]/)
    .filter(Boolean)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join('');
}

function buildPropsLiteral(props?: Record<string, any>): string {
  if (!props || Object.keys(props).length === 0) return '';
  const parts: string[] = [];
  for (const [k, v] of Object.entries(props)) {
    if (typeof v === 'string') parts.push(`${k}="${v}"`);
    else if (typeof v === 'boolean') parts.push(v ? k : `${k}={false}`);
    else parts.push(`${k}={${JSON.stringify(v)}}`);
  }
  return ' ' + parts.join(' ');
}

/**
 * Extract static asset imports from JSX/TSX content
 * Matches: import heroImg from './hero.jpg'
 * Returns: Array of relative asset paths
 */
function extractAssetImports(content: string): string[] {
  const assets: string[] = [];
  // Match: import identifier from './path/to/asset.ext'
  const importRegex = /import\s+\w+\s+from\s+['"](\.[^'"]+\.(jpg|jpeg|png|gif|svg|webp|ico))['"];?/gi;
  let m: RegExpExecArray | null;
  while ((m = importRegex.exec(content))) {
    assets.push(m[1]); // m[1] is the path, m[2] is the extension
  }
  return assets;
}

/**
 * Copy referenced assets from component files to public/assets/
 * Only processes JSX/TSX static imports (e.g., import heroImg from './hero.jpg')
 * @param sitePath - Root of Next.js app
 * @param componentPaths - Array of component file paths to scan
 * @param warnings - Warnings array to populate
 */
async function copyReferencedAssets(
  sitePath: string,
  componentPaths: string[],
  warnings: string[]
): Promise<void> {
  const assetsDir = path.join(sitePath, 'public', 'assets');
  await fs.mkdir(assetsDir, { recursive: true });

  for (const compPath of componentPaths) {
    try {
      const content = await fs.readFile(compPath, 'utf-8');
      const assetPaths = extractAssetImports(content);

      for (const relPath of assetPaths) {
        const compDir = path.dirname(compPath);
        const assetSrc = path.resolve(compDir, relPath);

        try {
          await fs.access(assetSrc);
          const assetName = path.basename(assetSrc);
          const assetDest = path.join(assetsDir, assetName);

          // Copy asset if not already present
          try {
            await fs.access(assetDest);
            warnings.push(`ASSET_EXISTS: ${assetName} already in public/assets/`);
          } catch {
            await fs.copyFile(assetSrc, assetDest);
          }
        } catch {
          warnings.push(`ASSET_NOT_FOUND: ${relPath} (referenced in ${path.basename(compPath)})`);
        }
      }
    } catch (err) {
      warnings.push(`COMPONENT_READ_FAILED: ${path.basename(compPath)}`);
    }
  }
}

export async function composePage(params: ComposePageParams): Promise<ComposePageResult> {
  const { sitePath, overwrite = true, dryRun = false } = params;
  const result: ComposePageResult = {
    success: false,
    path: '',
    changed: false,
    warnings: [],
    errors: [],
  };

  const targetPath = path.isAbsolute(params.pagePath)
    ? params.pagePath
    : path.join(sitePath, params.pagePath);
  result.path = targetPath;

  // Check overwrite
  try {
    const stat = await fs.stat(targetPath);
    if (stat.isFile() && !overwrite && !dryRun) {
      result.errors.push('FILE_EXISTS: Use overwrite=true to replace');
      return result;
    }
  } catch {
    // ok
  }

  // Compose imports and JSX
  const importMap = new Map<string, string>(); // path -> component name
  const body: string[] = [];

  params.sections.forEach((section, idx) => {
    const guessedName = section.componentName || toPascalCase(path.basename(section.importPath));
    // Deduplicate imports by path
    if (!importMap.has(section.importPath)) {
      importMap.set(section.importPath, guessedName);
    }
    body.push(`      <${guessedName}${buildPropsLiteral(section.props)} />`);
  });

  // Generate unique import statements
  const imports = Array.from(importMap.entries()).map(
    ([importPath, componentName]) => `import { ${componentName} } from '${importPath}';`
  );

  const content = `// Auto-generated by ui-template-bridge compose_page\n` +
    `import React from 'react';\n` +
    imports.join('\n') +
    `\n\nexport default function Page() {\n` +
    `  return (\n` +
    `    <main className=\"min-h-screen\">\n` +
    body.join('\n') +
    `\n    </main>\n` +
    `  );\n` +
    `}\n`;

  if (dryRun) {
    result.success = true;
    result.changed = true;
    result.preview = content;
    return result;
  }

  const writeRes = await writeFileAtomic(targetPath, { content });
  if (!writeRes.success) {
    result.errors.push(`WRITE_FAILED: ${writeRes.error || 'unknown error'}`);
    return result;
  }

  result.success = true;
  result.changed = true;
  return result;
}

